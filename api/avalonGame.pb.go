// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: avalonGame.proto

package api

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GameSession_GameState int32

const (
	GameSession_GAME_CREATED           GameSession_GameState = 0
	GameSession_MISSION_STARTED        GameSession_GameState = 10
	GameSession_MISSION_TEAM_PICKING   GameSession_GameState = 20
	GameSession_MISSION_TEAM_VOTING    GameSession_GameState = 25
	GameSession_MISSION_SUCCESS_VOTING GameSession_GameState = 26
	GameSession_MISSION_ENDED          GameSession_GameState = 30
	GameSession_POST_MISSIONS_ACTIONS  GameSession_GameState = 100
	GameSession_VIRTUOUS_TEAM_WON      GameSession_GameState = 150
	GameSession_EVIL_TEAM_WON          GameSession_GameState = 155
)

var GameSession_GameState_name = map[int32]string{
	0:   "GAME_CREATED",
	10:  "MISSION_STARTED",
	20:  "MISSION_TEAM_PICKING",
	25:  "MISSION_TEAM_VOTING",
	26:  "MISSION_SUCCESS_VOTING",
	30:  "MISSION_ENDED",
	100: "POST_MISSIONS_ACTIONS",
	150: "VIRTUOUS_TEAM_WON",
	155: "EVIL_TEAM_WON",
}

var GameSession_GameState_value = map[string]int32{
	"GAME_CREATED":           0,
	"MISSION_STARTED":        10,
	"MISSION_TEAM_PICKING":   20,
	"MISSION_TEAM_VOTING":    25,
	"MISSION_SUCCESS_VOTING": 26,
	"MISSION_ENDED":          30,
	"POST_MISSIONS_ACTIONS":  100,
	"VIRTUOUS_TEAM_WON":      150,
	"EVIL_TEAM_WON":          155,
}

func (x GameSession_GameState) String() string {
	return proto.EnumName(GameSession_GameState_name, int32(x))
}

func (GameSession_GameState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{1, 0}
}

type VoteContext_VoteOption int32

const (
	VoteContext_NEGATIVE VoteContext_VoteOption = 0
	VoteContext_POSITIVE VoteContext_VoteOption = 1
)

var VoteContext_VoteOption_name = map[int32]string{
	0: "NEGATIVE",
	1: "POSITIVE",
}

var VoteContext_VoteOption_value = map[string]int32{
	"NEGATIVE": 0,
	"POSITIVE": 1,
}

func (x VoteContext_VoteOption) String() string {
	return proto.EnumName(VoteContext_VoteOption_name, int32(x))
}

func (VoteContext_VoteOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{11, 0}
}

//UUID v4 as in RFC 4122 for identifying game sessions
type UUID struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UUID) Reset()         { *m = UUID{} }
func (m *UUID) String() string { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()    {}
func (*UUID) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{0}
}
func (m *UUID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUID.Merge(m, src)
}
func (m *UUID) XXX_Size() int {
	return m.Size()
}
func (m *UUID) XXX_DiscardUnknown() {
	xxx_messageInfo_UUID.DiscardUnknown(m)
}

var xxx_messageInfo_UUID proto.InternalMessageInfo

func (m *UUID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

//GameSession describes the game in progress
//Used in most parts of the API specifying exact session to perform actions on
type GameSession struct {
	GameId            *UUID                 `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	State             GameSession_GameState `protobuf:"varint,10,opt,name=state,proto3,enum=proto.GameSession_GameState" json:"state,omitempty"`
	Leader            *Player               `protobuf:"bytes,20,opt,name=leader,proto3" json:"leader,omitempty"`
	LastMissionResult *MissionResult        `protobuf:"bytes,30,opt,name=last_mission_result,json=lastMissionResult,proto3" json:"last_mission_result,omitempty"`
}

func (m *GameSession) Reset()         { *m = GameSession{} }
func (m *GameSession) String() string { return proto.CompactTextString(m) }
func (*GameSession) ProtoMessage()    {}
func (*GameSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{1}
}
func (m *GameSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameSession.Merge(m, src)
}
func (m *GameSession) XXX_Size() int {
	return m.Size()
}
func (m *GameSession) XXX_DiscardUnknown() {
	xxx_messageInfo_GameSession.DiscardUnknown(m)
}

var xxx_messageInfo_GameSession proto.InternalMessageInfo

func (m *GameSession) GetGameId() *UUID {
	if m != nil {
		return m.GameId
	}
	return nil
}

func (m *GameSession) GetState() GameSession_GameState {
	if m != nil {
		return m.State
	}
	return GameSession_GAME_CREATED
}

func (m *GameSession) GetLeader() *Player {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *GameSession) GetLastMissionResult() *MissionResult {
	if m != nil {
		return m.LastMissionResult
	}
	return nil
}

//GameConfig holds data about teams and session configuration to create session with
type GameConfig struct {
	GoodTeam   *VirtuousTeam   `protobuf:"bytes,10,opt,name=good_team,json=goodTeam,proto3" json:"good_team,omitempty"`
	EvilTeam   *EvilTeam       `protobuf:"bytes,20,opt,name=evil_team,json=evilTeam,proto3" json:"evil_team,omitempty"`
	Extensions *GameExtensions `protobuf:"bytes,100,opt,name=extensions,proto3" json:"extensions,omitempty"`
}

func (m *GameConfig) Reset()         { *m = GameConfig{} }
func (m *GameConfig) String() string { return proto.CompactTextString(m) }
func (*GameConfig) ProtoMessage()    {}
func (*GameConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{2}
}
func (m *GameConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameConfig.Merge(m, src)
}
func (m *GameConfig) XXX_Size() int {
	return m.Size()
}
func (m *GameConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GameConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GameConfig proto.InternalMessageInfo

func (m *GameConfig) GetGoodTeam() *VirtuousTeam {
	if m != nil {
		return m.GoodTeam
	}
	return nil
}

func (m *GameConfig) GetEvilTeam() *EvilTeam {
	if m != nil {
		return m.EvilTeam
	}
	return nil
}

func (m *GameConfig) GetExtensions() *GameExtensions {
	if m != nil {
		return m.Extensions
	}
	return nil
}

//GameExtensions holds flags specifying additional player roles and rules to be used during game session
type GameExtensions struct {
	PercivalAndMorgana bool `protobuf:"varint,1,opt,name=percival_and_morgana,json=percivalAndMorgana,proto3" json:"percival_and_morgana,omitempty"`
	AssassinAndMerlin  bool `protobuf:"varint,2,opt,name=assassin_and_merlin,json=assassinAndMerlin,proto3" json:"assassin_and_merlin,omitempty"`
	Oberon             bool `protobuf:"varint,3,opt,name=oberon,proto3" json:"oberon,omitempty"`
	Mordred            bool `protobuf:"varint,4,opt,name=mordred,proto3" json:"mordred,omitempty"`
}

func (m *GameExtensions) Reset()         { *m = GameExtensions{} }
func (m *GameExtensions) String() string { return proto.CompactTextString(m) }
func (*GameExtensions) ProtoMessage()    {}
func (*GameExtensions) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{3}
}
func (m *GameExtensions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameExtensions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameExtensions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameExtensions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameExtensions.Merge(m, src)
}
func (m *GameExtensions) XXX_Size() int {
	return m.Size()
}
func (m *GameExtensions) XXX_DiscardUnknown() {
	xxx_messageInfo_GameExtensions.DiscardUnknown(m)
}

var xxx_messageInfo_GameExtensions proto.InternalMessageInfo

func (m *GameExtensions) GetPercivalAndMorgana() bool {
	if m != nil {
		return m.PercivalAndMorgana
	}
	return false
}

func (m *GameExtensions) GetAssassinAndMerlin() bool {
	if m != nil {
		return m.AssassinAndMerlin
	}
	return false
}

func (m *GameExtensions) GetOberon() bool {
	if m != nil {
		return m.Oberon
	}
	return false
}

func (m *GameExtensions) GetMordred() bool {
	if m != nil {
		return m.Mordred
	}
	return false
}

type Player struct {
	Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UserName string `protobuf:"bytes,10,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{4}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

type EvilTeam struct {
	Members []*Player `protobuf:"bytes,10,rep,name=members,proto3" json:"members,omitempty"`
	//Ignored for now
	Assassin *Player `protobuf:"bytes,20,opt,name=assassin,proto3" json:"assassin,omitempty"`
	Oberon   *Player `protobuf:"bytes,30,opt,name=oberon,proto3" json:"oberon,omitempty"`
	Morgana  *Player `protobuf:"bytes,40,opt,name=morgana,proto3" json:"morgana,omitempty"`
}

func (m *EvilTeam) Reset()         { *m = EvilTeam{} }
func (m *EvilTeam) String() string { return proto.CompactTextString(m) }
func (*EvilTeam) ProtoMessage()    {}
func (*EvilTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{5}
}
func (m *EvilTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvilTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvilTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvilTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvilTeam.Merge(m, src)
}
func (m *EvilTeam) XXX_Size() int {
	return m.Size()
}
func (m *EvilTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_EvilTeam.DiscardUnknown(m)
}

var xxx_messageInfo_EvilTeam proto.InternalMessageInfo

func (m *EvilTeam) GetMembers() []*Player {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *EvilTeam) GetAssassin() *Player {
	if m != nil {
		return m.Assassin
	}
	return nil
}

func (m *EvilTeam) GetOberon() *Player {
	if m != nil {
		return m.Oberon
	}
	return nil
}

func (m *EvilTeam) GetMorgana() *Player {
	if m != nil {
		return m.Morgana
	}
	return nil
}

type VirtuousTeam struct {
	Members []*Player `protobuf:"bytes,10,rep,name=members,proto3" json:"members,omitempty"`
	//Ignored for now
	Merlin   *Player `protobuf:"bytes,20,opt,name=merlin,proto3" json:"merlin,omitempty"`
	Percival *Player `protobuf:"bytes,30,opt,name=percival,proto3" json:"percival,omitempty"`
}

func (m *VirtuousTeam) Reset()         { *m = VirtuousTeam{} }
func (m *VirtuousTeam) String() string { return proto.CompactTextString(m) }
func (*VirtuousTeam) ProtoMessage()    {}
func (*VirtuousTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{6}
}
func (m *VirtuousTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtuousTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VirtuousTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VirtuousTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtuousTeam.Merge(m, src)
}
func (m *VirtuousTeam) XXX_Size() int {
	return m.Size()
}
func (m *VirtuousTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtuousTeam.DiscardUnknown(m)
}

var xxx_messageInfo_VirtuousTeam proto.InternalMessageInfo

func (m *VirtuousTeam) GetMembers() []*Player {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *VirtuousTeam) GetMerlin() *Player {
	if m != nil {
		return m.Merlin
	}
	return nil
}

func (m *VirtuousTeam) GetPercival() *Player {
	if m != nil {
		return m.Percival
	}
	return nil
}

type PendingMission struct {
	MissionNumber uint32 `protobuf:"varint,10,opt,name=mission_number,json=missionNumber,proto3" json:"mission_number,omitempty"`
	TimesVoted    uint32 `protobuf:"varint,20,opt,name=times_voted,json=timesVoted,proto3" json:"times_voted,omitempty"`
}

func (m *PendingMission) Reset()         { *m = PendingMission{} }
func (m *PendingMission) String() string { return proto.CompactTextString(m) }
func (*PendingMission) ProtoMessage()    {}
func (*PendingMission) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{7}
}
func (m *PendingMission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingMission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingMission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingMission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingMission.Merge(m, src)
}
func (m *PendingMission) XXX_Size() int {
	return m.Size()
}
func (m *PendingMission) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingMission.DiscardUnknown(m)
}

var xxx_messageInfo_PendingMission proto.InternalMessageInfo

func (m *PendingMission) GetMissionNumber() uint32 {
	if m != nil {
		return m.MissionNumber
	}
	return 0
}

func (m *PendingMission) GetTimesVoted() uint32 {
	if m != nil {
		return m.TimesVoted
	}
	return 0
}

type MissionTeam struct {
	Members []*Player `protobuf:"bytes,10,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *MissionTeam) Reset()         { *m = MissionTeam{} }
func (m *MissionTeam) String() string { return proto.CompactTextString(m) }
func (*MissionTeam) ProtoMessage()    {}
func (*MissionTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{8}
}
func (m *MissionTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MissionTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MissionTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MissionTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MissionTeam.Merge(m, src)
}
func (m *MissionTeam) XXX_Size() int {
	return m.Size()
}
func (m *MissionTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_MissionTeam.DiscardUnknown(m)
}

var xxx_messageInfo_MissionTeam proto.InternalMessageInfo

func (m *MissionTeam) GetMembers() []*Player {
	if m != nil {
		return m.Members
	}
	return nil
}

type MissionResult struct {
	Failed bool `protobuf:"varint,10,opt,name=failed,proto3" json:"failed,omitempty"`
	//TODO: There must be a better way, than just 2 lists
	PositiveVotes []*Player `protobuf:"bytes,20,rep,name=positive_votes,json=positiveVotes,proto3" json:"positive_votes,omitempty"`
	NegativeVotes []*Player `protobuf:"bytes,30,rep,name=negative_votes,json=negativeVotes,proto3" json:"negative_votes,omitempty"`
}

func (m *MissionResult) Reset()         { *m = MissionResult{} }
func (m *MissionResult) String() string { return proto.CompactTextString(m) }
func (*MissionResult) ProtoMessage()    {}
func (*MissionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{9}
}
func (m *MissionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MissionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MissionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MissionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MissionResult.Merge(m, src)
}
func (m *MissionResult) XXX_Size() int {
	return m.Size()
}
func (m *MissionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_MissionResult.DiscardUnknown(m)
}

var xxx_messageInfo_MissionResult proto.InternalMessageInfo

func (m *MissionResult) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *MissionResult) GetPositiveVotes() []*Player {
	if m != nil {
		return m.PositiveVotes
	}
	return nil
}

func (m *MissionResult) GetNegativeVotes() []*Player {
	if m != nil {
		return m.NegativeVotes
	}
	return nil
}

type AssignTeamContext struct {
	Session *GameSession `protobuf:"bytes,10,opt,name=session,proto3" json:"session,omitempty"`
	Team    *MissionTeam `protobuf:"bytes,20,opt,name=team,proto3" json:"team,omitempty"`
}

func (m *AssignTeamContext) Reset()         { *m = AssignTeamContext{} }
func (m *AssignTeamContext) String() string { return proto.CompactTextString(m) }
func (*AssignTeamContext) ProtoMessage()    {}
func (*AssignTeamContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{10}
}
func (m *AssignTeamContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignTeamContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignTeamContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignTeamContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignTeamContext.Merge(m, src)
}
func (m *AssignTeamContext) XXX_Size() int {
	return m.Size()
}
func (m *AssignTeamContext) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignTeamContext.DiscardUnknown(m)
}

var xxx_messageInfo_AssignTeamContext proto.InternalMessageInfo

func (m *AssignTeamContext) GetSession() *GameSession {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *AssignTeamContext) GetTeam() *MissionTeam {
	if m != nil {
		return m.Team
	}
	return nil
}

type VoteContext struct {
	Session *GameSession           `protobuf:"bytes,10,opt,name=session,proto3" json:"session,omitempty"`
	Voter   *Player                `protobuf:"bytes,20,opt,name=voter,proto3" json:"voter,omitempty"`
	Vote    VoteContext_VoteOption `protobuf:"varint,30,opt,name=vote,proto3,enum=proto.VoteContext_VoteOption" json:"vote,omitempty"`
}

func (m *VoteContext) Reset()         { *m = VoteContext{} }
func (m *VoteContext) String() string { return proto.CompactTextString(m) }
func (*VoteContext) ProtoMessage()    {}
func (*VoteContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_5befea5ed4f8cd8c, []int{11}
}
func (m *VoteContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteContext.Merge(m, src)
}
func (m *VoteContext) XXX_Size() int {
	return m.Size()
}
func (m *VoteContext) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteContext.DiscardUnknown(m)
}

var xxx_messageInfo_VoteContext proto.InternalMessageInfo

func (m *VoteContext) GetSession() *GameSession {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *VoteContext) GetVoter() *Player {
	if m != nil {
		return m.Voter
	}
	return nil
}

func (m *VoteContext) GetVote() VoteContext_VoteOption {
	if m != nil {
		return m.Vote
	}
	return VoteContext_NEGATIVE
}

func init() {
	proto.RegisterEnum("proto.GameSession_GameState", GameSession_GameState_name, GameSession_GameState_value)
	proto.RegisterEnum("proto.VoteContext_VoteOption", VoteContext_VoteOption_name, VoteContext_VoteOption_value)
	proto.RegisterType((*UUID)(nil), "proto.UUID")
	proto.RegisterType((*GameSession)(nil), "proto.GameSession")
	proto.RegisterType((*GameConfig)(nil), "proto.GameConfig")
	proto.RegisterType((*GameExtensions)(nil), "proto.GameExtensions")
	proto.RegisterType((*Player)(nil), "proto.Player")
	proto.RegisterType((*EvilTeam)(nil), "proto.EvilTeam")
	proto.RegisterType((*VirtuousTeam)(nil), "proto.VirtuousTeam")
	proto.RegisterType((*PendingMission)(nil), "proto.PendingMission")
	proto.RegisterType((*MissionTeam)(nil), "proto.MissionTeam")
	proto.RegisterType((*MissionResult)(nil), "proto.MissionResult")
	proto.RegisterType((*AssignTeamContext)(nil), "proto.AssignTeamContext")
	proto.RegisterType((*VoteContext)(nil), "proto.VoteContext")
}

func init() { proto.RegisterFile("avalonGame.proto", fileDescriptor_5befea5ed4f8cd8c) }

var fileDescriptor_5befea5ed4f8cd8c = []byte{
	// 1096 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0x8f, 0xfb, 0x23, 0x4d, 0x5e, 0x9a, 0x34, 0x79, 0x4d, 0xfb, 0xf5, 0x76, 0x77, 0xf3, 0xad,
	0x0c, 0x65, 0x8b, 0xb4, 0x4a, 0x97, 0xb0, 0x8b, 0x00, 0x71, 0x20, 0x9b, 0x9a, 0x28, 0x82, 0x26,
	0x91, 0x9d, 0x06, 0xc4, 0xc5, 0x9a, 0xd6, 0xd3, 0x60, 0xc9, 0x3f, 0x22, 0x8f, 0x13, 0xed, 0xfe,
	0x09, 0xdc, 0x90, 0x90, 0xb8, 0x70, 0x84, 0x33, 0x07, 0xae, 0x88, 0x3b, 0xc7, 0x3d, 0x22, 0x71,
	0x41, 0xed, 0x3f, 0x82, 0x66, 0xec, 0x49, 0x9d, 0xad, 0x5b, 0xb1, 0x9c, 0x3c, 0xf3, 0x3e, 0x9f,
	0xcf, 0x9b, 0x79, 0xe3, 0xf7, 0x03, 0xaa, 0x64, 0x4e, 0xdc, 0xc0, 0xef, 0x12, 0x8f, 0x36, 0xa7,
	0x61, 0x10, 0x05, 0xb8, 0x2e, 0x3e, 0x7b, 0xf7, 0x27, 0x41, 0x30, 0x71, 0xe9, 0x91, 0xd8, 0x9d,
	0xcd, 0x2e, 0x8e, 0xa8, 0x37, 0x8d, 0x5e, 0xc6, 0x1c, 0xed, 0x01, 0xac, 0x9d, 0x9e, 0xf6, 0x8e,
	0xb1, 0x0e, 0xeb, 0x73, 0xe2, 0xce, 0xa8, 0xaa, 0xec, 0x2b, 0x87, 0x45, 0x23, 0xde, 0x68, 0xbf,
	0xae, 0x42, 0x89, 0x3b, 0x34, 0x29, 0x63, 0x4e, 0xe0, 0xe3, 0xdb, 0xb0, 0x31, 0x21, 0x1e, 0xb5,
	0x1c, 0x5b, 0xf0, 0x4a, 0xad, 0x52, 0xec, 0xa6, 0xc9, 0x7d, 0x18, 0x79, 0x8e, 0xf5, 0x6c, 0x6c,
	0xc1, 0x3a, 0x8b, 0x48, 0x44, 0x55, 0xd8, 0x57, 0x0e, 0x2b, 0xad, 0x07, 0x09, 0x27, 0xe5, 0x28,
	0x5e, 0x73, 0x8e, 0x11, 0x53, 0xf1, 0x00, 0xf2, 0x2e, 0x25, 0x36, 0x0d, 0xd5, 0xba, 0x70, 0x5c,
	0x4e, 0x44, 0x43, 0x97, 0xbc, 0xa4, 0xa1, 0x91, 0x80, 0x78, 0x0c, 0xdb, 0x2e, 0x61, 0x91, 0xe5,
	0x39, 0xc2, 0x8f, 0x15, 0x52, 0x36, 0x73, 0x23, 0xb5, 0x21, 0x34, 0xf5, 0x44, 0x73, 0x12, 0x83,
	0x86, 0xc0, 0x8c, 0x1a, 0x17, 0x2c, 0x99, 0xb4, 0xbf, 0x14, 0x28, 0x2e, 0x6e, 0x80, 0x55, 0xd8,
	0xec, 0xb6, 0x4f, 0x74, 0xab, 0x63, 0xe8, 0xed, 0x91, 0x7e, 0x5c, 0xcd, 0xe1, 0x36, 0x6c, 0x9d,
	0xf4, 0x4c, 0xb3, 0x37, 0xe8, 0x5b, 0xe6, 0xa8, 0x6d, 0x70, 0x23, 0xa0, 0x0a, 0x75, 0x69, 0x1c,
	0xe9, 0xed, 0x13, 0x6b, 0xd8, 0xeb, 0x7c, 0xde, 0xeb, 0x77, 0xab, 0x75, 0xfc, 0x1f, 0x6c, 0x2f,
	0x21, 0xe3, 0xc1, 0x88, 0x03, 0xf7, 0x70, 0x0f, 0x76, 0x17, 0x7e, 0x4e, 0x3b, 0x1d, 0xdd, 0x34,
	0x25, 0xb6, 0x87, 0x35, 0x28, 0x4b, 0x4c, 0xef, 0x1f, 0xeb, 0xc7, 0xd5, 0x06, 0xde, 0x83, 0x9d,
	0xe1, 0xc0, 0x1c, 0x59, 0x89, 0xdd, 0xb4, 0xda, 0x9d, 0x11, 0xff, 0x56, 0x6d, 0xdc, 0x85, 0xda,
	0xb8, 0x67, 0x8c, 0x4e, 0x07, 0xa7, 0x66, 0x7c, 0xc6, 0x97, 0x83, 0x7e, 0xf5, 0x07, 0x05, 0x11,
	0xca, 0xfa, 0xb8, 0xf7, 0xc5, 0xb5, 0xed, 0x47, 0x45, 0xfb, 0x49, 0x01, 0xe0, 0xd1, 0x75, 0x02,
	0xff, 0xc2, 0x99, 0xe0, 0x13, 0x28, 0x4e, 0x82, 0xc0, 0xb6, 0x22, 0x4a, 0x3c, 0xf1, 0x47, 0x4a,
	0xad, 0xed, 0xe4, 0xa1, 0xc6, 0x4e, 0x18, 0xcd, 0x82, 0x19, 0x1b, 0x51, 0xe2, 0x19, 0x05, 0xce,
	0xe2, 0x2b, 0x7c, 0x0c, 0x45, 0x3a, 0x77, 0xdc, 0x58, 0x11, 0xff, 0x8e, 0xad, 0x44, 0xa1, 0xcf,
	0x1d, 0x37, 0x66, 0xd3, 0x64, 0x85, 0xcf, 0x00, 0xe8, 0x8b, 0x88, 0xfa, 0xfc, 0x7d, 0x99, 0x6a,
	0x0b, 0xfa, 0x4e, 0xea, 0x97, 0xeb, 0x0b, 0xd0, 0x48, 0x11, 0xb5, 0x9f, 0x15, 0xa8, 0x2c, 0xc3,
	0xf8, 0x04, 0xea, 0x53, 0x1a, 0x9e, 0x3b, 0x73, 0xe2, 0x5a, 0xc4, 0xb7, 0x2d, 0x2f, 0x08, 0x27,
	0xc4, 0x27, 0x22, 0xd5, 0x0a, 0x06, 0x4a, 0xac, 0xed, 0xdb, 0x27, 0x31, 0x82, 0x4d, 0xd8, 0x26,
	0x8c, 0x11, 0xc6, 0x1c, 0x3f, 0x56, 0xd0, 0xd0, 0x75, 0x7c, 0x75, 0x45, 0x08, 0x6a, 0x12, 0xe2,
	0x02, 0x01, 0xe0, 0x2e, 0xe4, 0x83, 0x33, 0x1a, 0x06, 0xbe, 0xba, 0x2a, 0x28, 0xc9, 0x0e, 0x55,
	0xd8, 0xf0, 0x82, 0xd0, 0x0e, 0xa9, 0xad, 0xae, 0x09, 0x40, 0x6e, 0xb5, 0x67, 0x90, 0x8f, 0x53,
	0x10, 0x2b, 0xb0, 0x92, 0xa4, 0xfd, 0x9a, 0xb1, 0xe2, 0xd8, 0x78, 0x1f, 0x8a, 0x33, 0x46, 0x43,
	0xcb, 0x27, 0x5e, 0x9c, 0xe9, 0x45, 0xa3, 0xc0, 0x0d, 0x7d, 0xe2, 0x51, 0xed, 0x17, 0x05, 0x0a,
	0xf2, 0xad, 0xf0, 0x11, 0x6c, 0x78, 0xd4, 0x3b, 0xa3, 0x21, 0x53, 0x61, 0x7f, 0xf5, 0x66, 0x72,
	0x4b, 0x14, 0xdf, 0x85, 0x82, 0xbc, 0x73, 0x76, 0x19, 0x2c, 0x60, 0x5e, 0x2f, 0x49, 0x24, 0x8d,
	0xcc, 0x7a, 0x49, 0x02, 0x7b, 0x24, 0x02, 0x13, 0xaf, 0x78, 0x98, 0xc5, 0x93, 0xa8, 0xf6, 0xad,
	0x02, 0x9b, 0xe9, 0x74, 0xf8, 0xf7, 0x97, 0x3e, 0x80, 0x7c, 0xf2, 0xec, 0xd9, 0x95, 0x1b, 0x83,
	0x3c, 0x36, 0xf9, 0x03, 0xb3, 0xaf, 0xbc, 0x80, 0xb5, 0xaf, 0xa0, 0x32, 0xa4, 0xbe, 0xed, 0xf8,
	0x93, 0xa4, 0x6c, 0xf1, 0x00, 0x2a, 0xb2, 0xe2, 0xfd, 0x19, 0x3f, 0x56, 0x3c, 0x78, 0xd9, 0x28,
	0x27, 0xd6, 0xbe, 0x30, 0xe2, 0xff, 0xa1, 0x14, 0x39, 0x1e, 0x65, 0xd6, 0x3c, 0x88, 0xa8, 0x2d,
	0xee, 0x53, 0x36, 0x40, 0x98, 0xc6, 0xdc, 0xa2, 0x7d, 0x00, 0xa5, 0xc4, 0xe5, 0x1b, 0xc5, 0xa8,
	0x7d, 0xaf, 0x40, 0x79, 0xa9, 0x85, 0xf0, 0x4c, 0xba, 0x20, 0x8e, 0x4b, 0x6d, 0x71, 0x93, 0x82,
	0x91, 0xec, 0xf0, 0x29, 0x54, 0xa6, 0x01, 0x73, 0x22, 0x67, 0x4e, 0xc5, 0x2d, 0x98, 0x5a, 0xcf,
	0xf2, 0x5c, 0x96, 0x24, 0x7e, 0x2f, 0xc6, 0x55, 0x3e, 0x9d, 0x90, 0x94, 0xaa, 0x91, 0xa9, 0x92,
	0x24, 0xa1, 0xd2, 0x1c, 0xa8, 0xb5, 0x19, 0x73, 0x26, 0x22, 0x98, 0x4e, 0xe0, 0x47, 0xf4, 0x45,
	0x84, 0x8f, 0x61, 0x83, 0xc5, 0x4d, 0x36, 0x29, 0x76, 0xbc, 0xd9, 0x7e, 0x0d, 0x49, 0xc1, 0x77,
	0x60, 0x2d, 0x55, 0xe5, 0xb8, 0xdc, 0x40, 0x45, 0xa1, 0x0b, 0x5c, 0xfb, 0x5d, 0x81, 0x12, 0x3f,
	0xf4, 0xbf, 0x9d, 0xf2, 0x16, 0xac, 0xf3, 0xa8, 0x6e, 0xe9, 0xed, 0x31, 0x86, 0xef, 0xc1, 0x1a,
	0x5f, 0x88, 0xe4, 0xa8, 0xb4, 0x1e, 0xca, 0x16, 0x75, 0x7d, 0xa8, 0x58, 0x0f, 0xa6, 0x11, 0x77,
	0x2d, 0xa8, 0xda, 0x21, 0xc0, 0xb5, 0x0d, 0x37, 0xa1, 0xd0, 0xd7, 0xbb, 0xed, 0x51, 0x6f, 0xac,
	0x57, 0x73, 0x7c, 0x37, 0x1c, 0x98, 0x3d, 0xb1, 0x53, 0x5a, 0xbf, 0xad, 0xcb, 0x41, 0x16, 0xce,
	0x9d, 0x73, 0x8a, 0x1f, 0x42, 0xb9, 0x13, 0x52, 0x12, 0x2d, 0x26, 0x5b, 0x2d, 0x75, 0xff, 0xb8,
	0x71, 0xee, 0x65, 0x84, 0xa4, 0xe5, 0xf0, 0x53, 0xa8, 0x8e, 0x68, 0xe8, 0x39, 0x7e, 0x4a, 0x9c,
	0xc1, 0xdc, 0xdb, 0x6d, 0xc6, 0x63, 0xb7, 0x29, 0xc7, 0x6e, 0x53, 0xe7, 0x63, 0x57, 0xcb, 0xe1,
	0x11, 0x40, 0x97, 0x46, 0x52, 0x9b, 0x9e, 0xa0, 0xb7, 0x1c, 0xf9, 0x14, 0x4a, 0x5d, 0x1a, 0x2d,
	0xda, 0x49, 0xd6, 0x69, 0xaf, 0xf7, 0x67, 0x2d, 0x87, 0x9f, 0xc0, 0x56, 0x97, 0x46, 0x4b, 0x35,
	0x9d, 0xa5, 0xcc, 0x9a, 0x05, 0x5a, 0x0e, 0x3f, 0x82, 0xf2, 0x70, 0xc6, 0xbe, 0xb9, 0x9e, 0x92,
	0x59, 0xda, 0xdb, 0x5e, 0xa8, 0xd6, 0xa5, 0xd1, 0x6b, 0x15, 0x9c, 0x25, 0x97, 0x53, 0x62, 0x99,
	0xaa, 0xe5, 0xb0, 0x2b, 0x13, 0x3b, 0x5d, 0xac, 0x6a, 0xc2, 0xbe, 0x91, 0xf2, 0x77, 0x3c, 0xf5,
	0xc7, 0x50, 0xe9, 0xd2, 0x28, 0xed, 0xe5, 0xae, 0x30, 0x52, 0x3c, 0x2d, 0x87, 0xcf, 0x01, 0x79,
	0x72, 0x7d, 0x16, 0x84, 0x59, 0xfa, 0x54, 0x5e, 0xde, 0x71, 0xbe, 0x0e, 0x3b, 0xcb, 0x3e, 0xcc,
	0xd9, 0xf9, 0x39, 0x65, 0xec, 0xcd, 0xdc, 0x3c, 0x7f, 0xf8, 0xc7, 0x65, 0x43, 0x79, 0x75, 0xd9,
	0x50, 0xfe, 0xbe, 0x6c, 0x28, 0xdf, 0x5d, 0x35, 0x72, 0xaf, 0xae, 0x1a, 0xb9, 0x3f, 0xaf, 0x1a,
	0xb9, 0xaf, 0x57, 0xc9, 0xd4, 0x39, 0xcb, 0x0b, 0xc1, 0xfb, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff,
	0xf2, 0x98, 0x04, 0xe1, 0x02, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GameServiceClient is the client API for GameService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GameServiceClient interface {
	//CreateSession with specified players and options.
	//Should be called first to obtain a handle for created game,
	//that will be used in most other parts of API.
	CreateSession(ctx context.Context, in *GameConfig, opts ...grpc.CallOption) (*GameSession, error)
	//TerminateSession end current game session, freeing it's UUID and other resources
	TerminateSession(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*types.Empty, error)
	//GetSession returns in-progress game session data
	GetSession(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*GameSession, error)
	//GetEvilTeam returns information about the bad boys in the game session
	GetEvilTeam(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*EvilTeam, error)
	//GetVirtuousTeam returns information about the good guys in the game session
	GetVirtuousTeam(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*VirtuousTeam, error)
	//PushGameState proceeds game to the next state, returns updated session data
	PushGameState(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*GameSession, error)
	//GetPendingMission returns current mission in progress
	GetPendingMission(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*PendingMission, error)
	//AssignMissionTeam proposes a set of players, picked by leader, to be voted for sending them on a mission.
	//Returns null if there is no mission pending.
	AssignMissionTeam(ctx context.Context, in *AssignTeamContext, opts ...grpc.CallOption) (*types.Empty, error)
	//GetMissionTeam returns a team, assigned for pending mission, if any.
	//Returns null if there is no team assigned yet.
	GetMissionTeam(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*MissionTeam, error)
	//Votes are only accepted for games in MISSION_*_VOTING states
	//Call PushGameState AFTER ALL players voted!
	VoteForMissionTeam(ctx context.Context, in *VoteContext, opts ...grpc.CallOption) (*types.Empty, error)
	VoteForMissionSuccess(ctx context.Context, in *VoteContext, opts ...grpc.CallOption) (*types.Empty, error)
}

type gameServiceClient struct {
	cc *grpc.ClientConn
}

func NewGameServiceClient(cc *grpc.ClientConn) GameServiceClient {
	return &gameServiceClient{cc}
}

func (c *gameServiceClient) CreateSession(ctx context.Context, in *GameConfig, opts ...grpc.CallOption) (*GameSession, error) {
	out := new(GameSession)
	err := c.cc.Invoke(ctx, "/proto.GameService/CreateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) TerminateSession(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.GameService/TerminateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) GetSession(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*GameSession, error) {
	out := new(GameSession)
	err := c.cc.Invoke(ctx, "/proto.GameService/GetSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) GetEvilTeam(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*EvilTeam, error) {
	out := new(EvilTeam)
	err := c.cc.Invoke(ctx, "/proto.GameService/GetEvilTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) GetVirtuousTeam(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*VirtuousTeam, error) {
	out := new(VirtuousTeam)
	err := c.cc.Invoke(ctx, "/proto.GameService/GetVirtuousTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) PushGameState(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*GameSession, error) {
	out := new(GameSession)
	err := c.cc.Invoke(ctx, "/proto.GameService/PushGameState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) GetPendingMission(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*PendingMission, error) {
	out := new(PendingMission)
	err := c.cc.Invoke(ctx, "/proto.GameService/GetPendingMission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) AssignMissionTeam(ctx context.Context, in *AssignTeamContext, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.GameService/AssignMissionTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) GetMissionTeam(ctx context.Context, in *GameSession, opts ...grpc.CallOption) (*MissionTeam, error) {
	out := new(MissionTeam)
	err := c.cc.Invoke(ctx, "/proto.GameService/GetMissionTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) VoteForMissionTeam(ctx context.Context, in *VoteContext, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.GameService/VoteForMissionTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameServiceClient) VoteForMissionSuccess(ctx context.Context, in *VoteContext, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/proto.GameService/VoteForMissionSuccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GameServiceServer is the server API for GameService service.
type GameServiceServer interface {
	//CreateSession with specified players and options.
	//Should be called first to obtain a handle for created game,
	//that will be used in most other parts of API.
	CreateSession(context.Context, *GameConfig) (*GameSession, error)
	//TerminateSession end current game session, freeing it's UUID and other resources
	TerminateSession(context.Context, *GameSession) (*types.Empty, error)
	//GetSession returns in-progress game session data
	GetSession(context.Context, *UUID) (*GameSession, error)
	//GetEvilTeam returns information about the bad boys in the game session
	GetEvilTeam(context.Context, *GameSession) (*EvilTeam, error)
	//GetVirtuousTeam returns information about the good guys in the game session
	GetVirtuousTeam(context.Context, *GameSession) (*VirtuousTeam, error)
	//PushGameState proceeds game to the next state, returns updated session data
	PushGameState(context.Context, *GameSession) (*GameSession, error)
	//GetPendingMission returns current mission in progress
	GetPendingMission(context.Context, *GameSession) (*PendingMission, error)
	//AssignMissionTeam proposes a set of players, picked by leader, to be voted for sending them on a mission.
	//Returns null if there is no mission pending.
	AssignMissionTeam(context.Context, *AssignTeamContext) (*types.Empty, error)
	//GetMissionTeam returns a team, assigned for pending mission, if any.
	//Returns null if there is no team assigned yet.
	GetMissionTeam(context.Context, *GameSession) (*MissionTeam, error)
	//Votes are only accepted for games in MISSION_*_VOTING states
	//Call PushGameState AFTER ALL players voted!
	VoteForMissionTeam(context.Context, *VoteContext) (*types.Empty, error)
	VoteForMissionSuccess(context.Context, *VoteContext) (*types.Empty, error)
}

// UnimplementedGameServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGameServiceServer struct {
}

func (*UnimplementedGameServiceServer) CreateSession(ctx context.Context, req *GameConfig) (*GameSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (*UnimplementedGameServiceServer) TerminateSession(ctx context.Context, req *GameSession) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateSession not implemented")
}
func (*UnimplementedGameServiceServer) GetSession(ctx context.Context, req *UUID) (*GameSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSession not implemented")
}
func (*UnimplementedGameServiceServer) GetEvilTeam(ctx context.Context, req *GameSession) (*EvilTeam, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvilTeam not implemented")
}
func (*UnimplementedGameServiceServer) GetVirtuousTeam(ctx context.Context, req *GameSession) (*VirtuousTeam, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVirtuousTeam not implemented")
}
func (*UnimplementedGameServiceServer) PushGameState(ctx context.Context, req *GameSession) (*GameSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushGameState not implemented")
}
func (*UnimplementedGameServiceServer) GetPendingMission(ctx context.Context, req *GameSession) (*PendingMission, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPendingMission not implemented")
}
func (*UnimplementedGameServiceServer) AssignMissionTeam(ctx context.Context, req *AssignTeamContext) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignMissionTeam not implemented")
}
func (*UnimplementedGameServiceServer) GetMissionTeam(ctx context.Context, req *GameSession) (*MissionTeam, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMissionTeam not implemented")
}
func (*UnimplementedGameServiceServer) VoteForMissionTeam(ctx context.Context, req *VoteContext) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VoteForMissionTeam not implemented")
}
func (*UnimplementedGameServiceServer) VoteForMissionSuccess(ctx context.Context, req *VoteContext) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VoteForMissionSuccess not implemented")
}

func RegisterGameServiceServer(s *grpc.Server, srv GameServiceServer) {
	s.RegisterService(&_GameService_serviceDesc, srv)
}

func _GameService_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/CreateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).CreateSession(ctx, req.(*GameConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_TerminateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).TerminateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/TerminateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).TerminateSession(ctx, req.(*GameSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/GetSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).GetSession(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_GetEvilTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).GetEvilTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/GetEvilTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).GetEvilTeam(ctx, req.(*GameSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_GetVirtuousTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).GetVirtuousTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/GetVirtuousTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).GetVirtuousTeam(ctx, req.(*GameSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_PushGameState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).PushGameState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/PushGameState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).PushGameState(ctx, req.(*GameSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_GetPendingMission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).GetPendingMission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/GetPendingMission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).GetPendingMission(ctx, req.(*GameSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_AssignMissionTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignTeamContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).AssignMissionTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/AssignMissionTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).AssignMissionTeam(ctx, req.(*AssignTeamContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_GetMissionTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).GetMissionTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/GetMissionTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).GetMissionTeam(ctx, req.(*GameSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_VoteForMissionTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VoteContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).VoteForMissionTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/VoteForMissionTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).VoteForMissionTeam(ctx, req.(*VoteContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameService_VoteForMissionSuccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VoteContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServiceServer).VoteForMissionSuccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GameService/VoteForMissionSuccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServiceServer).VoteForMissionSuccess(ctx, req.(*VoteContext))
	}
	return interceptor(ctx, in, info, handler)
}

var _GameService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.GameService",
	HandlerType: (*GameServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSession",
			Handler:    _GameService_CreateSession_Handler,
		},
		{
			MethodName: "TerminateSession",
			Handler:    _GameService_TerminateSession_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _GameService_GetSession_Handler,
		},
		{
			MethodName: "GetEvilTeam",
			Handler:    _GameService_GetEvilTeam_Handler,
		},
		{
			MethodName: "GetVirtuousTeam",
			Handler:    _GameService_GetVirtuousTeam_Handler,
		},
		{
			MethodName: "PushGameState",
			Handler:    _GameService_PushGameState_Handler,
		},
		{
			MethodName: "GetPendingMission",
			Handler:    _GameService_GetPendingMission_Handler,
		},
		{
			MethodName: "AssignMissionTeam",
			Handler:    _GameService_AssignMissionTeam_Handler,
		},
		{
			MethodName: "GetMissionTeam",
			Handler:    _GameService_GetMissionTeam_Handler,
		},
		{
			MethodName: "VoteForMissionTeam",
			Handler:    _GameService_VoteForMissionTeam_Handler,
		},
		{
			MethodName: "VoteForMissionSuccess",
			Handler:    _GameService_VoteForMissionSuccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "avalonGame.proto",
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAvalonGame(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GameSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastMissionResult != nil {
		{
			size, err := m.LastMissionResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.State != 0 {
		i = encodeVarintAvalonGame(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x50
	}
	if m.GameId != nil {
		{
			size, err := m.GameId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GameConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Extensions != nil {
		{
			size, err := m.Extensions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.EvilTeam != nil {
		{
			size, err := m.EvilTeam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.GoodTeam != nil {
		{
			size, err := m.GoodTeam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}

func (m *GameExtensions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameExtensions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameExtensions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mordred {
		i--
		if m.Mordred {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Oberon {
		i--
		if m.Oberon {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AssassinAndMerlin {
		i--
		if m.AssassinAndMerlin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PercivalAndMorgana {
		i--
		if m.PercivalAndMorgana {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Player) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintAvalonGame(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x52
	}
	if m.Id != 0 {
		i = encodeVarintAvalonGame(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvilTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvilTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvilTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Morgana != nil {
		{
			size, err := m.Morgana.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.Oberon != nil {
		{
			size, err := m.Oberon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Assassin != nil {
		{
			size, err := m.Assassin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAvalonGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	return len(dAtA) - i, nil
}

func (m *VirtuousTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtuousTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtuousTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Percival != nil {
		{
			size, err := m.Percival.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Merlin != nil {
		{
			size, err := m.Merlin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAvalonGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	return len(dAtA) - i, nil
}

func (m *PendingMission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingMission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingMission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimesVoted != 0 {
		i = encodeVarintAvalonGame(dAtA, i, uint64(m.TimesVoted))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.MissionNumber != 0 {
		i = encodeVarintAvalonGame(dAtA, i, uint64(m.MissionNumber))
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *MissionTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MissionTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MissionTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAvalonGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	return len(dAtA) - i, nil
}

func (m *MissionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MissionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MissionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NegativeVotes) > 0 {
		for iNdEx := len(m.NegativeVotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NegativeVotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAvalonGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.PositiveVotes) > 0 {
		for iNdEx := len(m.PositiveVotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositiveVotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAvalonGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Failed {
		i--
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	return len(dAtA) - i, nil
}

func (m *AssignTeamContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignTeamContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignTeamContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Team != nil {
		{
			size, err := m.Team.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}

func (m *VoteContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vote != 0 {
		i = encodeVarintAvalonGame(dAtA, i, uint64(m.Vote))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Voter != nil {
		{
			size, err := m.Voter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAvalonGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}

func encodeVarintAvalonGame(dAtA []byte, offset int, v uint64) int {
	offset -= sovAvalonGame(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UUID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAvalonGame(uint64(l))
	}
	return n
}

func (m *GameSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != nil {
		l = m.GameId.Size()
		n += 1 + l + sovAvalonGame(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAvalonGame(uint64(m.State))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	if m.LastMissionResult != nil {
		l = m.LastMissionResult.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	return n
}

func (m *GameConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GoodTeam != nil {
		l = m.GoodTeam.Size()
		n += 1 + l + sovAvalonGame(uint64(l))
	}
	if m.EvilTeam != nil {
		l = m.EvilTeam.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	return n
}

func (m *GameExtensions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PercivalAndMorgana {
		n += 2
	}
	if m.AssassinAndMerlin {
		n += 2
	}
	if m.Oberon {
		n += 2
	}
	if m.Mordred {
		n += 2
	}
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAvalonGame(uint64(m.Id))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovAvalonGame(uint64(l))
	}
	return n
}

func (m *EvilTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovAvalonGame(uint64(l))
		}
	}
	if m.Assassin != nil {
		l = m.Assassin.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	if m.Oberon != nil {
		l = m.Oberon.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	if m.Morgana != nil {
		l = m.Morgana.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	return n
}

func (m *VirtuousTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovAvalonGame(uint64(l))
		}
	}
	if m.Merlin != nil {
		l = m.Merlin.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	if m.Percival != nil {
		l = m.Percival.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	return n
}

func (m *PendingMission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MissionNumber != 0 {
		n += 1 + sovAvalonGame(uint64(m.MissionNumber))
	}
	if m.TimesVoted != 0 {
		n += 2 + sovAvalonGame(uint64(m.TimesVoted))
	}
	return n
}

func (m *MissionTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovAvalonGame(uint64(l))
		}
	}
	return n
}

func (m *MissionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failed {
		n += 2
	}
	if len(m.PositiveVotes) > 0 {
		for _, e := range m.PositiveVotes {
			l = e.Size()
			n += 2 + l + sovAvalonGame(uint64(l))
		}
	}
	if len(m.NegativeVotes) > 0 {
		for _, e := range m.NegativeVotes {
			l = e.Size()
			n += 2 + l + sovAvalonGame(uint64(l))
		}
	}
	return n
}

func (m *AssignTeamContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAvalonGame(uint64(l))
	}
	if m.Team != nil {
		l = m.Team.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	return n
}

func (m *VoteContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAvalonGame(uint64(l))
	}
	if m.Voter != nil {
		l = m.Voter.Size()
		n += 2 + l + sovAvalonGame(uint64(l))
	}
	if m.Vote != 0 {
		n += 2 + sovAvalonGame(uint64(m.Vote))
	}
	return n
}

func sovAvalonGame(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAvalonGame(x uint64) (n int) {
	return sovAvalonGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameId == nil {
				m.GameId = &UUID{}
			}
			if err := m.GameId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= GameSession_GameState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &Player{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMissionResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastMissionResult == nil {
				m.LastMissionResult = &MissionResult{}
			}
			if err := m.LastMissionResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodTeam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoodTeam == nil {
				m.GoodTeam = &VirtuousTeam{}
			}
			if err := m.GoodTeam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvilTeam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EvilTeam == nil {
				m.EvilTeam = &EvilTeam{}
			}
			if err := m.EvilTeam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &GameExtensions{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameExtensions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameExtensions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameExtensions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercivalAndMorgana", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PercivalAndMorgana = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssassinAndMerlin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssassinAndMerlin = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oberon", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Oberon = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mordred", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mordred = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvilTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvilTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvilTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Player{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assassin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assassin == nil {
				m.Assassin = &Player{}
			}
			if err := m.Assassin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oberon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oberon == nil {
				m.Oberon = &Player{}
			}
			if err := m.Oberon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Morgana", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Morgana == nil {
				m.Morgana = &Player{}
			}
			if err := m.Morgana.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtuousTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtuousTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtuousTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Player{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merlin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merlin == nil {
				m.Merlin = &Player{}
			}
			if err := m.Merlin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percival", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Percival == nil {
				m.Percival = &Player{}
			}
			if err := m.Percival.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingMission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingMission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingMission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionNumber", wireType)
			}
			m.MissionNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissionNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimesVoted", wireType)
			}
			m.TimesVoted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimesVoted |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MissionTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MissionTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MissionTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Player{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MissionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MissionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MissionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveVotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositiveVotes = append(m.PositiveVotes, &Player{})
			if err := m.PositiveVotes[len(m.PositiveVotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeVotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NegativeVotes = append(m.NegativeVotes, &Player{})
			if err := m.NegativeVotes[len(m.NegativeVotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignTeamContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignTeamContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignTeamContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &GameSession{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Team == nil {
				m.Team = &MissionTeam{}
			}
			if err := m.Team.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &GameSession{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvalonGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voter == nil {
				m.Voter = &Player{}
			}
			if err := m.Voter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= VoteContext_VoteOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvalonGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAvalonGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAvalonGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAvalonGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAvalonGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAvalonGame
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAvalonGame
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAvalonGame
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAvalonGame        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAvalonGame          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAvalonGame = fmt.Errorf("proto: unexpected end of group")
)
